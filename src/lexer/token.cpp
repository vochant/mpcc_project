#ifndef __MPCC_SRC_TOKEN
#define __MPCC_SRC_TOKEN

#include "include/lexer/token.hpp"

const std::map<Token::Type, std::string> Token::typeNames = {
	{Token::Type::Class, 				"class"},
	{Token::Type::Const, 				"const"},
	{Token::Type::Constructor, 			"constructor"},
	{Token::Type::Delete,				"delete"},
	{Token::Type::Destructor,			"destructor"},
	{Token::Type::Dowhile,				"dowhile"},
	{Token::Type::Else,					"else"},
	{Token::Type::Enumerate,			"enum"},
	{Token::Type::False,				"false"},
	{Token::Type::For,					"for"},
	{Token::Type::Global,				"global"},
	{Token::Type::If,					"if"},
	{Token::Type::Import,				"import"},
	{Token::Type::Let,					"let"},
	{Token::Type::Object,				"object"},
	{Token::Type::Private,				"private"},
	{Token::Type::Public,				"public"},
	{Token::Type::Return,				"return"},
	{Token::Type::True,					"true"},
	{Token::Type::Var,					"var"},
	{Token::Type::While,				"while"},
	{Token::Type::Null,					"null"},
	{Token::Type::Function,				"function"},

	{Token::Type::Assign,				"assign(\"=\")"},
	{Token::Type::Asterisk,				"asterisk(\"*\")"},
	{Token::Type::AsteriskAssign,		"asterisk_assign(\"*=\")"},
	{Token::Type::BitwiseAnd,			"bitwise_and(\"&\")"},
	{Token::Type::BitwiseAndAssign,		"bitwise_and_assign(\"&=\")"},
	{Token::Type::BitwiseLeft,			"bitwise_left(\"<<\")"},
	{Token::Type::BitwiseLeftAssign,	"bitwise_left_assign(\"<<=\")"},
	{Token::Type::BitwiseNot,			"bitwise_not(\"~\")"},
	{Token::Type::BitwiseOr,			"bitwise_or(\"|\")"},
	{Token::Type::BitwiseOrAssign,		"bitwise_or_assign(\"|=\")"},
	{Token::Type::BitwiseRight,			"bitwise_right(\">>\")"},
	{Token::Type::BitwiseRightAssign,	"bitwise_right_assign(\">>=\")"},
	{Token::Type::BitwiseXor,			"bitwise_xor(\"^\")"},
	{Token::Type::BitwiseXorAssign,		"bitwise_xor_assign(\"^=\")"},
	{Token::Type::Comma,				"comma(\",\")"},
	{Token::Type::Decrement,			"decrement(\"--\")"},
	{Token::Type::End,					"end(End Of File)"},
	{Token::Type::Equal,				"equal(\"==\")"},
	{Token::Type::Error,				"error(Error)"},
	{Token::Type::Extand,				"extand(\".\")"},
	{Token::Type::Float,				"float(Float Object)"},
	{Token::Type::Greater,				"greater(\">\")"},
	{Token::Type::GreaterEqual,			"greater_equal(\">=\")"},
	{Token::Type::Identifier,			"identifier(Identifier)"},
	{Token::Type::Increment,			"increment(\"++\")"},
	{Token::Type::Integer,				"integer(Integer Object)"},
	{Token::Type::Lambda,				"lambda(\"$\")"},
	{Token::Type::LBrace,				"left_brace(\"{\")"},
	{Token::Type::LBracket,				"left_bracket(\"[\")"},
	{Token::Type::Less,					"less(\"<\")"},
	{Token::Type::LessEqual,			"less_equal(\"<=\")"},
	{Token::Type::LogicalAnd,			"logical_and(\"&&\")"},
	{Token::Type::LogicalNot,			"logical_not(\"!\")"},
	{Token::Type::LogicalOr,			"logical_or(\"||\")"},
	{Token::Type::LParan,				"left_paran(\"(\")"},
	{Token::Type::Minus,				"minus(\"-\")"},
	{Token::Type::MinusAssign,			"minus_assign(\"-=\")"},
	{Token::Type::Modulus,				"modulus(\"%\")"},
	{Token::Type::ModulusAssign,		"modulus_assign(\"%=\")"},
	{Token::Type::NotEqual,				"not_equal(\"!=\")"},
	{Token::Type::Plus,					"plus(\"+\")"},
	{Token::Type::PlusAssign,			"plus_assign(\"+=\")"},
	{Token::Type::RBrace,				"right_brace(\"}\")"},
	{Token::Type::RBracket,				"right_bracket(\"]\")"},
	{Token::Type::RParan,				"right_paran(\")\")"},
	{Token::Type::Semicolon,			"semicolon(\";\")"},
	{Token::Type::Slash,				"slash(\"/\")"},
	{Token::Type::SlashAssign,			"slash_assign(\"/=\")"},
	{Token::Type::As,					"as(\":\")"}
};

#endif