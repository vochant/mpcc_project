#ifndef __MPCC_SRC_TOKEN
#define __MPCC_SRC_TOKEN

#include "lexer/token.hpp"

Token::Token(const Type type, const std::string value) : type(type), value(value) {}

Token::Token(const std::string value, const Type type) : type(type), value(value) {}

const std::map<Token::Type, std::string> Token::typeNames = {
    {Token::Type::Class,				"class"},
    {Token::Type::Const,				"const"},
    {Token::Type::Constructor,			"constructor"},
    {Token::Type::Delete,				"delete"},
    {Token::Type::Destructor,			"destructor"},
    {Token::Type::Dowhile,				"dowhile"},
    {Token::Type::Else,					"else"},
    {Token::Type::Enumerate,			"enum"},
    {Token::Type::False,				"false"},
    {Token::Type::For,					"for"},
    {Token::Type::Global,				"global"},
    {Token::Type::If,					"if"},
    {Token::Type::Import,				"import"},
    {Token::Type::Let,					"let"},
    {Token::Type::Private,				"private"},
    {Token::Type::Protected,            "protected"},
    {Token::Type::Public,				"public"},
    {Token::Type::Return,				"return"},
    {Token::Type::True,					"true"},
    {Token::Type::Var,					"var"},
    {Token::Type::While,				"while"},
    {Token::Type::Null,					"null"},
    {Token::Type::Func,	    			"func"},
    {Token::Type::FunctionDef,          "function"},
    {Token::Type::Static,               "static"},
    {Token::Type::Method,               "method"},
    {Token::Type::Final,                "final"},
    {Token::Type::Value,                "value"},
    {Token::Type::New,                  "new"},
    {Token::Type::Break,                "break"},
    {Token::Type::Continue,             "continue"},

    {Token::Type::Arrow,                "arrow(\"=>\")"},
    {Token::Type::Assign,				"assign(\"=\")"},
    {Token::Type::Asterisk,				"asterisk(\"*\")"},
    {Token::Type::AsteriskAssign,		"asterisk_assign(\"*=\")"},
    {Token::Type::BitwiseAnd,			"bitwise_and(\"&\")"},
    {Token::Type::BitwiseAndAssign,		"bitwise_and_assign(\"&=\")"},
    {Token::Type::BitwiseLeft,			"bitwise_left(\"<<\")"},
    {Token::Type::BitwiseLeftAssign,	"bitwise_left_assign(\"<<=\")"},
    {Token::Type::BitwiseNot,			"bitwise_not(\"~\")"},
    {Token::Type::BitwiseOr,			"bitwise_or(\"|\")"},
    {Token::Type::BitwiseOrAssign,		"bitwise_or_assign(\"|=\")"},
    {Token::Type::BitwiseRight,			"bitwise_right(\">>\")"},
    {Token::Type::BitwiseRightAssign,	"bitwise_right_assign(\">>=\")"},
    {Token::Type::BitwiseXor,			"bitwise_xor(\"^\")"},
    {Token::Type::BitwiseXorAssign,		"bitwise_xor_assign(\"^=\")"},
    {Token::Type::Comma,				"comma(\",\")"},
    {Token::Type::Decrement,			"decrement(\"--\")"},
    {Token::Type::End,					"end(End Of File)"},
    {Token::Type::Equal,				"equal(\"==\")"},
    {Token::Type::Error,				"error(Error)"},
    {Token::Type::Extand,				"extand(\".\")"},
    {Token::Type::Float,				"float(Float Object)"},
    {Token::Type::Greater,				"greater(\">\")"},
    {Token::Type::GreaterEqual,			"greater_equal(\">=\")"},
    {Token::Type::Identifier,			"identifier(Identifier)"},
    {Token::Type::Increment,			"increment(\"++\")"},
    {Token::Type::Integer,				"integer(Integer Object)"},
    {Token::Type::Lambda,				"lambda(\"$\")"},
    {Token::Type::LBrace,				"left_brace(\"{\")"},
    {Token::Type::LBracket,				"left_bracket(\"[\")"},
    {Token::Type::Less,					"less(\"<\")"},
    {Token::Type::LessEqual,			"less_equal(\"<=\")"},
    {Token::Type::LogicalAnd,			"logical_and(\"&&\")"},
    {Token::Type::LogicalNot,			"logical_not(\"!\")"},
    {Token::Type::LogicalOr,			"logical_or(\"||\")"},
    {Token::Type::LParan,				"left_paran(\"(\")"},
    {Token::Type::Minus,				"minus(\"-\")"},
    {Token::Type::MinusAssign,			"minus_assign(\"-=\")"},
    {Token::Type::Modulus,				"modulus(\"%\")"},
    {Token::Type::ModulusAssign,		"modulus_assign(\"%=\")"},
    {Token::Type::NotEqual,				"not_equal(\"!=\")"},
    {Token::Type::Plus,					"plus(\"+\")"},
    {Token::Type::PlusAssign,			"plus_assign(\"+=\")"},
    {Token::Type::RBrace,				"right_brace(\"}\")"},
    {Token::Type::RBracket,				"right_bracket(\"]\")"},
    {Token::Type::RParan,				"right_paran(\")\")"},
    {Token::Type::Semicolon,			"semicolon(\";\")"},
    {Token::Type::Slash,				"slash(\"/\")"},
    {Token::Type::SlashAssign,			"slash_assign(\"/=\")"},
    {Token::Type::As,					"as(\":\")"},
    {Token::Type::More,					"more(\"...\")"},
    {Token::Type::ForceExtand,          "force_extand(\"::\")"},
    {Token::Type::Pow,                  "pow(\"**\")"},
    {Token::Type::FullEqual,            "full_equal(\"===\")"},
    {Token::Type::NotFullEqual,         "not_full_equal(\"!==\")"}
};

#endif